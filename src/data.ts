export const questions = [
  {
    id: 1,
    question: 'Что такое promise в JavaScript?',
    answers: [
      {
        text: 'Функция вызываемая через заданный интервал времени',
        correct: false,
      },
      {
        text: 'Объект представляющий завершение (или ошибку) асинхронной операции',
        correct: true,
      },
      {
        text: 'Техника для обработки ошибок',
        correct: false,
      },
      {
        text: 'Способ оптимизации производительности',
        correct: false,
      },
    ],
  },
  {
    id: 2,
    question:
      'Какая основная цель использования стрелочных функций (Arrow Function) в JavaScript?',
    answers: [
      {
        text: 'Укорачивание синтаксиса функций',
        correct: false,
      },
      {
        text: 'Автоматическое создание глобальных переменных',
        correct: false,
      },
      {
        text: 'Изменение области видимости this',
        correct: true,
      },
      {
        text: 'Ускорение времени выполнения функций',
        correct: false,
      },
    ],
  },
  {
    id: 3,
    question: 'Что такое замыкание (Closure) в JavaScript?',
    answers: [
      {
        text: 'Ошибка, связанная с неправильным использованием области видимости',
        correct: false,
      },
      {
        text: 'Функция вместе с лексическим окружением, в котором она была объявлена',
        correct: true,
      },
      {
        text: 'Паттерн проектирования для инкапсуляции',
        correct: false,
      },
      {
        text: 'Способ закрытия функций от внешних переменных',
        correct: false,
      },
    ],
  },
  {
    id: 4,
    question:
      'Какие особенности имеет ключевое слово let по сравнению с var в JavaScript?',
    answers: [
      {
        text: 'let позволяет повторно объявлять переменные в той же области видимости',
        correct: false,
      },
      {
        text: 'let имеет блочную область видимости в отличии от функциональной у var',
        correct: true,
      },
      {
        text: 'let и var идентичны различия только в названии',
        correct: false,
      },
      {
        text: 'let ускоряет процесс выполнения кода по сравнению с var',
        correct: false,
      },
    ],
  },
  {
    id: 5,
    question: 'Что такое прототипное наследование в JavaScript?',
    answers: [
      {
        text: 'Способ создания новых объектов на основе существующих классов',
        correct: false,
      },
      {
        text: 'Паттерн, при котором объекты наследуют свойства и методы от других объектов',
        correct: true,
      },
      {
        text: 'Техника копирования свойств одного объекта в другой',
        correct: false,
      },
      {
        text: 'Метод переопределения функций в JavaScript',
        correct: false,
      },
    ],
  },
  {
    id: 6,
    question: 'Какова цель методов map, filter и reduce в JavaScript',
    answers: [
      {
        text: 'map для парсинга данных, filter для добавления элементов в массив, reduce для уменьшения размера массива',
        correct: false,
      },
      {
        text: 'map для модификации каждого элемента массива, filter для выборки элементов по условию, reduce для сертывания массива в одно значение',
        correct: true,
      },
      {
        text: 'map и filter для изменения размера массива, reduce для генерации новых массивов',
        correct: false,
      },
      {
        text: 'Все эти методы используются для сортировки массивов',
        correct: false,
      },
    ],
  },
  {
    id: 7,
    question: 'Как работает асинхронность в JavaScript?',
    answers: [
      {
        text: 'JavaScript использует многопоточность для выполнения асинхронных операций',
        correct: false,
      },
      {
        text: 'Асинхронные операции выполняются с использованием обратных вызовов (callbacks)',
        correct: false,
      },
      {
        text: 'JavaScript использует событийный цикл и обещания (promises) для управления асинхронными операциями',
        correct: true,
      },
      {
        text: 'Асинхронность в JavaScript реализуется исключительно через Web Workers',
        correct: false,
      },
    ],
  },
  {
    id: 8,
    question:
      'Какой метод в классовых компонентах React выполняется непосредственно перед рендерингом?',
    answers: [
      {
        text: 'componentDidUpdate',
        correct: false,
      },
      {
        text: 'componentDidMount',
        correct: false,
      },
      {
        text: 'render',
        correct: false,
      },
      {
        text: 'componentWillUpdate',
        correct: true,
      },
    ],
  },
  {
    id: 9,
    question: 'Что делает хук useState в React?',
    answers: [
      {
        text: 'Создает состояние в функциональном компоненте',
        correct: true,
      },
      {
        text: 'Обновляет состояние компонента',
        correct: false,
      },
      {
        text: 'Синхронизирует состояние с localStorage',
        correct: false,
      },
      {
        text: 'Подключает компонент к Redux-стору',
        correct: false,
      },
    ],
  },
  {
    id: 10,
    question:
      'Какой хук React используется для выполнения побочных эффектов в функциональных компонентах?',
    answers: [
      {
        text: 'useState',
        correct: false,
      },
      {
        text: 'useEffect',
        correct: true,
      },
      {
        text: 'useContext',
        correct: false,
      },
      {
        text: 'useReducer',
        correct: false,
      },
    ],
  },
  {
    id: 11,
    question:
      'Вы разрабатываете веб-приложение, которое работает с конфиденциальными пользовательскими данными. В каком из следующих мест следует проводить валидацию входных данных для обеспечения максимальной безопасности?',
    answers: [
      {
        text: 'На стороне клиента перед отправкой данных на сервер',
        correct: false,
      },
      {
        text: 'На прокси-сервере перед перенаправлением запросов на бэкенд',
        correct: false,
      },
      {
        text: 'На стороне сервера перед обработкой данных',
        correct: true,
      },
      {
        text: 'В базе данных через триггеры или ограничения на уровне схемы',
        correct: false,
      },
    ],
  },
  {
    id: 12,
    question:
      'Ваша команда работает над веб-приложением, которое испытвает задержки в отрисовке из-за большого объема данных, загружаемых на клиентскую сторону. Вы решаете применить стратегию оптимизации для уменьшения задержек. Какой из следующих подходов вы бы выбрали?',
    answers: [
      {
        text: 'Использование WebSockets для постоянного соединения с сервером и асинхронной загрузки данных',
        correct: false,
      },
      {
        text: 'Применение ServiceWorkers для кэширования данных и работы приложения в оффлайн режиме',
        correct: false,
      },
      {
        text: 'Реализация Virtual DOM для оптимизации процесса отрисовки изменений на странице',
        correct: false,
      },
      {
        text: 'Использование Pagination или Infinity Scrolling для постраничной загрузки данных',
        correct: true,
      },
    ],
  },
  {
    id: 13,
    question:
      'В рамкаш вашего проекта испльзуется React с Redux. Вы оптимизируете производительность компонента который зависит от часто изменяющихся данных в Redux store. Какой из следующих подходов вы бы использовали, чтобы минимизировать ненужные рендеры компонента при изминениях, которые не затрагивают этот компонент?',
    answers: [
      {
        text: 'Испльзование React.memo() для предотвращения рендеринга, если пропсы компонента не изменились',
        correct: true,
      },
      {
        text: 'Приминение useEffect с зависимостью от всего Redux store',
        correct: false,
      },
      {
        text: 'Использование shouldComponentUpdate для ручного контроля процесса обновления компонента',
        correct: false,
      },
      {
        text: 'Использование реселекторов (reselect библиотека) для вычисления производных данных',
        correct: false,
      },
    ],
  },
  {
    id: 14,
    question:
      'Вы работаете над оптимизацией производительности веб-приложения. Ваша задача уменьшить время загрузки страницы. Какой из следующих подходов вы бы испльзовали для достижения этой цели?',
    answers: [
      {
        text: 'Испльзование async и defer атрибутов в тегах <script> для контроля загрузки внешних JavaScript файлов',
        correct: false,
      },
      {
        text: 'Загрузка всех JavaScript и CSS файлов в начале HTML-документа для предотвращения блокировки отрисовки страницы',
        correct: true,
      },
      {
        text: 'Использование CSS анимаций вместо JavaScript для анимаций элементов на странице, чтобы уменьшить использование JavaScript',
        correct: false,
      },
      {
        text: 'Удаление всех изображений с сайта, чтобы уменьшить общий размер ресурсов, загружаемых на странице',
        correct: false,
      },
    ],
  },
  {
    id: 15,
    question:
      'Какой тип данных в JavaScript является наиболее подходящим для представления объектов с динамическими свойствами?',
    answers: [
      {
        text: 'Array',
        correct: false,
      },
      {
        text: 'Object',
        correct: true,
      },
      {
        text: 'String',
        correct: false,
      },
      {
        text: 'Number',
        correct: false,
      },
    ],
  },
]

export const earnings = [
  { id: 1, amount: '$ 100' },
  { id: 2, amount: '$ 200' },
  { id: 3, amount: '$ 300' },
  { id: 4, amount: '$ 500' },
  { id: 5, amount: '$ 1 000' },
  { id: 6, amount: '$ 2 000' },
  { id: 7, amount: '$ 4 000' },
  { id: 8, amount: '$ 8 000' },
  { id: 9, amount: '$ 16 000' },
  { id: 10, amount: '$ 32 000' },
  { id: 11, amount: '$ 64 000' },
  { id: 12, amount: '$ 125 000' },
  { id: 13, amount: '$ 250 000' },
  { id: 14, amount: '$ 500 000' },
  { id: 15, amount: '$ 1 MILLION' },
].reverse()